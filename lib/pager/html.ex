defmodule Pager.HTML do
  @moduledoc """
  This module contains HTML helpers to be used along with pages.
  """

  @view_module Application.compile_env(:pager, :view_module, Pager.HTML.View)

  @doc """
  Returns the pagination links for the given page.
  You can customize which view should be used to render the pagination using `config :pager, view_module: MyView`.
  You are expected to provide a "pagination.html" template for the given view module.
  The `@conn` and `@pages` assigns will be available in the template, the second one
  representing the blueprint items generated by the provider.
  """
  def pagination_links(%Plug.Conn{} = conn, %Pager.Page{__blueprint__: pages}) do
    Phoenix.View.render_existing(@view_module, "pagination.html", conn: conn, pages: pages)
  end

  @doc """
  Returns the first page link for the given page.
  If the page's blueprint does not contain an item of type `:first`, nothing is returned.
  """
  def first_page_link(%Plug.Conn{} = conn, %Pager.Page{__blueprint__: pages}) do
    if first_page = Enum.find(pages, &(&1.type == :first)) do
      Pager.HTML.Helpers.page_link(conn, first_page)
    end
  end

  @doc """
  Returns the prev page link for the given page.
  Relies solely on `Pager.Page.prev_page/1` to determine the previous page without checking for bounds or the blueprint.
  """
  def prev_page_link(%Plug.Conn{} = conn, %Pager.Page{} = page) do
    Pager.HTML.Helpers.page_link(conn, %{
      type: :prev,
      text: "‹ Prev",
      number: Pager.Page.prev_page(page),
      states: []
    })
  end

  @doc """
  Returns the prev page link for the given page.
  Raises if the page's blueprint does not contain an item of type `:prev`.
  For a naive implementation, use `Pager.Page.prev_page/1` instead.
  """
  def prev_page_link!(%Plug.Conn{} = conn, %Pager.Page{__blueprint__: pages}) do
    if prev_page = Enum.find(pages, &(&1.type == :prev)) do
      Pager.HTML.Helpers.page_link(conn, prev_page)
    else
      raise "No prev page blueprint found in #{inspect(pages)}"
    end
  end

  @doc """
  Returns the next page link for the given page blueprint structure.
  Relies solely on `Pager.Page.next_page/1` to determine the next page without checking for bounds or the blueprint.
  """
  def next_page_link(%Plug.Conn{} = conn, %Pager.Page{} = page) do
    Pager.HTML.Helpers.page_link(conn, %{
      type: :next,
      text: "Next ›",
      number: Pager.Page.next_page(page),
      states: []
    })
  end

  @doc """
  Returns the next page link for the given page.
  Raises if the page's blueprint does not contain an item of type `:next`.
  For a naive implementation, use `Pager.Page.next_page/1` instead.
  """
  def next_page_link!(%Plug.Conn{} = conn, %Pager.Page{__blueprint__: pages}) do
    if next_page = Enum.find(pages, &(&1.type == :next)) do
      Pager.HTML.Helpers.page_link(conn, next_page)
    else
      raise "No next page blueprint found in #{inspect(pages)}"
    end
  end

  @doc """
  Returns the last page link for the given page.
  If the page's blueprint does not contain an item of type `:last`, nothing is returned.
  """
  def last_page_link(%Plug.Conn{} = conn, %Pager.Page{__blueprint__: pages}) do
    if last_page = Enum.find(pages, &(&1.type == :last)) do
      Pager.HTML.Helpers.page_link(conn, last_page)
    end
  end
end
